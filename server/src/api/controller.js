/**
 * Server API controller.
 * @module api/controller
 */

var log    = require(`${SERVER_ROOT}/server/log`);
var model  = require(`${SERVER_ROOT}/api/model`);
var routes = require(`${SERVER_ROOT}/api/routes`);
var util   = require(`${SERVER_ROOT}/util`);

module.exports.handleRequest = handleRequest;

/**
 * Handle an HTTP request.
 * Matches the endpoint in the request to its appropriate handler, or badRequest if there is an
 * error.
 * @param port The port the client connected to.
 * @param request The client's request.
 * @param response The server's response.
 */
function handleRequest(request, response) {
    log.trace(module, handleRequest);
    // Set error handler.
    request.on('error', badRequest.bind(null, request, response));
    // Find endpoint.
    const { method, url } = request;
    const endpoint = getRequestHandler(method, url);
    if (util.isNullOrUndefined(endpoint)) {
        return badRequest(request, response);
    }
    // Call endpoint handler.
    if (method == 'GET') {
        return model.startRequest(request, null)
            .then(requestID => endpoint.callback.call(null))
            .then(({status, body}) => endRequest(null, response, status, body))
        ;
    } else if (method == 'POST') {
        return handlePost(request, response, endpoint)
    }
    // No handler for requested endpoint.
    return badRequest(request, response);
}

function getRequestHandler(method, url) {
    for (var i = 0; i < routes.endpoints.length; ++i) {
        const endpoint = routes.endpoints[i];
        if (method === endpoint.method && endpoint.href === url) {
            return endpoint;
        }
    }
    return null;
}

function handlePost(request, response, endpoint) {
    var inputs    = null;
    var requestID = null;
    return getRequestBody(request)
        .then(body   => getJsonElements(body, endpoint.inputs))
        .then(object => {
            inputs = object;
            return startRequest(request, inputs.id);
        })
        .then(reqID => {
            requestID = reqID;
            return endpoint.callback.call(null, inputs);
        })
        .then(({status, body}) => endRequest(requestID, response, status, body))
        .catch(error           => badRequest(request, response, error, requestID))
    ;
}

function startRequest(request, client) {
    log.trace(module, startRequest);
    return model.startRequest(request, client);
}

function endRequest(requestID, response, status, body) {
    log.trace(module, endRequest);
    response.statusCode = status;
    response.setHeader('Content-Type', 'application/json');
    // FIXME workaround for client regex which assumes the links don't have an `inputs` field.
    body.links = [];
    for (var i = 0; i < routes.endpoints.length; ++i) {
        body.links.push({
            'rel':    routes.endpoints[i].rel,
            'href':   routes.endpoints[i].href,
            'method': routes.endpoints[i].method
        });
    }
    const json = JSON.stringify(body);
    response.end(json);
    if (!(util.isNullOrUndefined(requestID))) {
        return model.endRequest(requestID, response.statusCode);
    }
}

function badRequest(request, response, error, requestID) {
    // Create response body.
    var body = { 'error': 1 };
    if (util.isNullOrUndefined(error)) {
        body.message = `Bad request: ${request.method} ${request.url}`;
    } else if (error instanceof Error && !(error instanceof util.RequestError)) {
        body.message = 'Internal server error';
    } else {
        body.message = error.message;
    }
    // Send response.
    endRequest(requestID, response, 400, body);
    // Crash if the error was an exception generated by V8, but don't crash on self-generated
    // exceptions (util.RequestError).
    const service = request.socket.encrypted ? 'HTTPS' : 'HTTP';
    if (error instanceof Error && !(error instanceof util.RequestError)) {
        log.error(`[${service}] ${error.message}`);
        log.error(error.stack);
        process.exit(1);
    } else {
        log.warn(`[${service}] ${body.message}`);
    }
}

/**
 * Get the body data from a request.
 * @param request The request.
 * @param response The response.
 */
function getRequestBody(request) {
    return new Promise((resolve, reject) => {
        var body = '';
        request.on('data', data => {
            body += data;
            // Check for buffer overrun attack. Return error if data too large.
            if (body.length > 1e6) {
                body = '';
                reject(new util.RequestError('Request body too large'));
            }
        });
        request.on('end', () => { resolve(body) });
    });
}

/**
 * Extract JSON objects from HTTP request body data with rudimentary type-checking.
 * @param body A buffer che HTTP request body.
 * @param elems A dictionary associating object names to their expected types, e.g. 'string',
 * 'object' or 'number.'
 */
function getJsonElements(body, elems) {
    return new Promise((resolve, reject) => {
        // Try to parse the body as JSON.
        try {
            var object = JSON.parse(body);
        } catch (error) {
            return reject(new util.RequestError(error.message));
        }
        // Extract the elements named by 'elems'.
        var result = {};
        for (var name in elems) {
            const type = elems[name];
            if (util.isNullOrUndefined(object[name])) {
                reject(new util.RequestError(`${name}: undefined property`));
            }
            if (typeof object[name] !== type) {
                reject(new util.RequestError(`${name}: expected ${type}, got ${typeof object[name]}`));
            }
            result[name] = object[name];
        }
        resolve(result);
    });
}
